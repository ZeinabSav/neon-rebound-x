<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Neon Rebound X</title>
<style>
/* ============================================================
   GLOBAL RESET & FONTS
   ============================================================ */
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600&display=swap');

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --c-bg:       #02030f;
  --c-cyan:     #00eeff;
  --c-orange:   #ff6a00;
  --c-green:    #00ff88;
  --c-red:      #ff2255;
  --c-panel:    rgba(0,238,255,0.05);
  --c-border:   rgba(0,238,255,0.18);
  --font-hud:   'Orbitron', monospace;
  --font-body:  'Rajdhani', sans-serif;
}

html, body {
  width: 100%; height: 100%;
  background: var(--c-bg);
  display: flex; align-items: center; justify-content: center;
  overflow: hidden;
  font-family: var(--font-body);
  color: #fff;
  user-select: none;
}

/* Animated grid background */
body::before {
  content: '';
  position: fixed; inset: 0;
  background-image:
    linear-gradient(rgba(0,238,255,0.03) 1px, transparent 1px),
    linear-gradient(90deg, rgba(0,238,255,0.03) 1px, transparent 1px);
  background-size: 48px 48px;
  animation: gridScroll 20s linear infinite;
  pointer-events: none;
  z-index: 0;
}
@keyframes gridScroll {
  from { background-position: 0 0; }
  to   { background-position: 48px 48px; }
}

/* Vignette */
body::after {
  content: '';
  position: fixed; inset: 0;
  background: radial-gradient(ellipse at center, transparent 50%, rgba(2,3,15,0.85) 100%);
  pointer-events: none; z-index: 1;
}

/* ============================================================
   WRAPPER & CANVAS
   ============================================================ */
#wrapper {
  position: relative; z-index: 2;
  display: flex; flex-direction: column; align-items: center;
}

canvas {
  display: block;
  border: 1px solid var(--c-border);
  box-shadow:
    0 0 0 1px rgba(0,238,255,0.06),
    0 0 60px rgba(0,238,255,0.07),
    0 0 120px rgba(0,238,255,0.04);
  image-rendering: crisp-edges;
}

/* ============================================================
   OVERLAY SCREENS  (layered over canvas)
   ============================================================ */
#overlay {
  position: absolute; inset: 0;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  gap: 0;
  background: rgba(2,3,15,0.88);
  backdrop-filter: blur(8px);
  z-index: 10;
  transition: opacity 0.5s ease;
}
#overlay.fade-out { opacity: 0; pointer-events: none; }
#overlay.hidden   { display: none; }

/* ‚îÄ‚îÄ Title ‚îÄ‚îÄ */
.title-wrap {
  position: relative;
  margin-bottom: 8px;
}
.game-title {
  font-family: var(--font-hud);
  font-weight: 900;
  font-size: clamp(2.2rem, 6vw, 3.8rem);
  letter-spacing: 0.08em;
  line-height: 1;
  background: linear-gradient(135deg, var(--c-cyan) 0%, #fff 45%, var(--c-orange) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  filter: drop-shadow(0 0 18px rgba(0,238,255,0.7));
  animation: titlePulse 3s ease-in-out infinite;
}
@keyframes titlePulse {
  0%,100% { filter: drop-shadow(0 0 18px rgba(0,238,255,0.7)); }
  50%      { filter: drop-shadow(0 0 32px rgba(0,238,255,1)) drop-shadow(0 0 60px rgba(255,106,0,0.4)); }
}
.title-sub {
  font-family: var(--font-hud);
  font-size: 0.7rem;
  letter-spacing: 0.45em;
  color: rgba(255,255,255,0.3);
  text-align: center;
  margin-top: 6px;
  margin-bottom: 36px;
}

/* ‚îÄ‚îÄ Section label ‚îÄ‚îÄ */
.section-label {
  font-family: var(--font-hud);
  font-size: 0.62rem;
  letter-spacing: 0.3em;
  color: rgba(0,238,255,0.45);
  margin-bottom: 12px;
  text-transform: uppercase;
}

/* ‚îÄ‚îÄ Difficulty buttons ‚îÄ‚îÄ */
.diff-row {
  display: flex; gap: 12px;
  margin-bottom: 36px;
  flex-wrap: wrap;
  justify-content: center;
}
.diff-btn {
  font-family: var(--font-hud);
  font-size: 0.72rem;
  letter-spacing: 0.2em;
  padding: 11px 28px;
  border: 1px solid rgba(255,255,255,0.15);
  background: rgba(255,255,255,0.03);
  color: rgba(255,255,255,0.5);
  cursor: pointer;
  text-transform: uppercase;
  transition: all 0.22s;
  outline: none;
  clip-path: polygon(8px 0%, 100% 0%, calc(100% - 8px) 100%, 0% 100%);
}
.diff-btn:hover {
  border-color: var(--c-cyan);
  color: var(--c-cyan);
  background: rgba(0,238,255,0.07);
  box-shadow: 0 0 20px rgba(0,238,255,0.2);
}
.diff-btn.active {
  border-color: var(--c-cyan);
  color: var(--c-cyan);
  background: rgba(0,238,255,0.12);
  box-shadow: 0 0 28px rgba(0,238,255,0.3), inset 0 0 12px rgba(0,238,255,0.06);
}
.diff-btn.active.medium { border-color: var(--c-orange); color: var(--c-orange); background: rgba(255,106,0,0.1); box-shadow: 0 0 28px rgba(255,106,0,0.3); }
.diff-btn.active.hard   { border-color: var(--c-red);    color: var(--c-red);    background: rgba(255,34,85,0.1);  box-shadow: 0 0 28px rgba(255,34,85,0.3); }

/* ‚îÄ‚îÄ Start / Restart button ‚îÄ‚îÄ */
.cta-btn {
  font-family: var(--font-hud);
  font-size: 0.85rem;
  letter-spacing: 0.3em;
  padding: 15px 52px;
  border: 1px solid var(--c-cyan);
  background: rgba(0,238,255,0.08);
  color: var(--c-cyan);
  cursor: pointer;
  text-transform: uppercase;
  transition: all 0.25s;
  outline: none;
  position: relative;
  overflow: hidden;
}
.cta-btn::before {
  content: '';
  position: absolute; inset: 0;
  background: linear-gradient(90deg, transparent, rgba(0,238,255,0.15), transparent);
  transform: translateX(-100%);
  transition: transform 0.5s;
}
.cta-btn:hover::before { transform: translateX(100%); }
.cta-btn:hover {
  background: rgba(0,238,255,0.18);
  box-shadow: 0 0 36px rgba(0,238,255,0.4);
}

/* ‚îÄ‚îÄ Result banner ‚îÄ‚îÄ */
.result-banner {
  font-family: var(--font-hud);
  font-size: clamp(1.4rem, 4vw, 2.4rem);
  font-weight: 700;
  letter-spacing: 0.12em;
  margin-bottom: 32px;
  text-align: center;
  line-height: 1.3;
}
.result-banner .winner { display: block; font-size: 0.65em; letter-spacing: 0.3em; opacity: 0.5; margin-bottom: 4px; }

/* ‚îÄ‚îÄ Hint ‚îÄ‚îÄ */
.hint-row {
  font-family: var(--font-body);
  font-size: 0.8rem;
  letter-spacing: 0.12em;
  color: rgba(255,255,255,0.2);
  margin-top: 28px;
  text-align: center;
  line-height: 2;
}

/* ‚îÄ‚îÄ Pause badge ‚îÄ‚îÄ */
#pause-badge {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%,-50%);
  font-family: var(--font-hud);
  font-size: 1.1rem;
  letter-spacing: 0.4em;
  color: var(--c-cyan);
  text-shadow: 0 0 24px var(--c-cyan);
  background: rgba(2,3,15,0.8);
  backdrop-filter: blur(6px);
  border: 1px solid rgba(0,238,255,0.25);
  padding: 16px 40px;
  z-index: 9;
  display: none;
  animation: pausePulse 1.4s ease-in-out infinite;
}
@keyframes pausePulse {
  0%,100% { opacity:1; } 50% { opacity:0.4; }
}

/* ‚îÄ‚îÄ Separator ‚îÄ‚îÄ */
.sep { width: 220px; height: 1px; background: linear-gradient(90deg, transparent, rgba(0,238,255,0.25), transparent); margin: 0 auto 28px; }

/* Responsive scale */
@media (max-width: 700px) {
  .game-title { font-size: 1.8rem; }
}
</style>
</head>
<body>
<div id="wrapper">
  <canvas id="canvas"></canvas>

  <!-- ‚îÄ‚îÄ PAUSE badge (inside wrapper, over canvas) ‚îÄ‚îÄ -->
  <div id="pause-badge">‚è∏ PAUSED</div>

  <!-- ‚îÄ‚îÄ OVERLAY (Start / Game Over) ‚îÄ‚îÄ -->
  <div id="overlay">
    <!-- Content is injected by JS depending on state -->
  </div>
</div>

<script>
/* ================================================================
   NEON REBOUND X  ‚Äî  Complete Pong Game
   Single HTML file, no external libraries.

   SECTIONS:
   1. Config & Constants
   2. State Management
   3. Canvas Setup & Resize
   4. Particle System
   5. Ball Object
   6. Paddle Objects
   7. AI Logic
   8. Collision Detection
   9. Scoring & Win Condition
   10. Drawing / Rendering
   11. Overlay / UI Management
   12. Input Handling
   13. Main Game Loop
   14. Initialisation & Boot
================================================================ */


/* ================================================================
   1. CONFIG & CONSTANTS
================================================================ */
const W = 960;   // logical canvas width
const H = 580;   // logical canvas height

const PADDLE_W      = 14;
const PADDLE_H      = 96;
const PADDLE_MARGIN = 28;   // distance of paddle from edge
const BALL_RADIUS   = 9;
const WIN_SCORE     = 7;
const TRAIL_MAX     = 22;   // number of trail segments

// Per-difficulty config
const DIFF = {
  easy: {
    label:      'EASY',
    ballSpeed:  5.0,
    speedBoost: 0.18,   // speed added per paddle hit
    maxSpeed:   11,
    aiSpeed:    2.4,    // max px per frame AI can move
    aiPredict:  0.0,    // 0 = purely reactive, 1 = fully predictive
    aiError:    38,     // max random error offset (px)
    color:      '#00eeff',
  },
  medium: {
    label:      'MEDIUM',
    ballSpeed:  6.8,
    speedBoost: 0.25,
    maxSpeed:   14,
    aiSpeed:    4.2,
    aiPredict:  0.45,
    aiError:    18,
    color:      '#ff6a00',
  },
  hard: {
    label:      'HARD',
    ballSpeed:  9.0,
    speedBoost: 0.38,
    maxSpeed:   20,
    aiSpeed:    7.5,
    aiPredict:  0.92,
    aiError:    4,
    color:      '#ff2255',
  },
};

/* ================================================================
   2. STATE MANAGEMENT
================================================================ */
const STATE = { START: 'start', PLAYING: 'playing', PAUSED: 'paused', GAMEOVER: 'gameover' };

let gameState  = STATE.START;
let difficulty = 'easy';
let scoreL     = 0;
let scoreR     = 0;
let winner     = null;   // 'player' | 'ai'
let animId     = null;
let lastTs     = 0;

// Score flash effect
let scoreFlashL = 0;
let scoreFlashR = 0;

/* ================================================================
   3. CANVAS SETUP & RESIZE
================================================================ */
const canvas  = document.getElementById('canvas');
const ctx     = canvas.getContext('2d');
canvas.width  = W;
canvas.height = H;

function scaleCanvas() {
  const s = Math.min(window.innerWidth / (W + 32), window.innerHeight / (H + 32));
  canvas.style.width  = (W * s) + 'px';
  canvas.style.height = (H * s) + 'px';
}
scaleCanvas();
window.addEventListener('resize', scaleCanvas);

/* ================================================================
   4. PARTICLE SYSTEM
================================================================ */
let particles = [];

function spawnScoreParticles(x, y, color) {
  for (let i = 0; i < 60; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 2 + Math.random() * 7;
    particles.push({
      x, y,
      vx:    Math.cos(angle) * speed,
      vy:    Math.sin(angle) * speed,
      life:  1.0,
      decay: 0.018 + Math.random() * 0.022,
      size:  2 + Math.random() * 4,
      color,
      glow:  color,
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x    += p.vx * dt;
    p.y    += p.vy * dt;
    p.vy   += 0.12 * dt;   // gravity
    p.vx   *= 0.98;
    p.life -= p.decay * dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.save();
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.shadowColor = p.glow;
    ctx.shadowBlur  = 10;
    ctx.fillStyle   = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

/* ================================================================
   5. BALL
================================================================ */
let ball = {};

function createBall(dirX = 1) {
  const cfg   = DIFF[difficulty];
  const angle = (Math.random() * 50 - 25) * Math.PI / 180;
  ball = {
    x:      W / 2,
    y:      H / 2,
    vx:     dirX * cfg.ballSpeed * Math.cos(angle),
    vy:     cfg.ballSpeed * Math.sin(angle),
    speed:  cfg.ballSpeed,
    trail:  [],
    // small launch delay
    delay:  60,
  };
}

function updateBall(dt) {
  if (ball.delay > 0) { ball.delay -= dt; return; }

  // Store trail
  ball.trail.push({ x: ball.x, y: ball.y });
  if (ball.trail.length > TRAIL_MAX) ball.trail.shift();

  ball.x += ball.vx * dt;
  ball.y += ball.vy * dt;
}

function drawBall() {
  if (ball.delay > 0) {
    // Pulsing "ready" dot
    const alpha = 0.4 + 0.4 * Math.sin(Date.now() * 0.008);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.shadowColor = '#00eeff'; ctx.shadowBlur = 24;
    ctx.fillStyle   = '#00eeff';
    ctx.beginPath();
    ctx.arc(W / 2, H / 2, BALL_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    return;
  }

  // ‚îÄ‚îÄ Trail ‚îÄ‚îÄ
  for (let i = 0; i < ball.trail.length; i++) {
    const t   = ball.trail[i];
    const pct = (i + 1) / ball.trail.length;  // 0‚Üí1 oldest‚Üínewest
    const r   = BALL_RADIUS * pct * 0.85;
    ctx.save();
    ctx.globalAlpha = pct * 0.5;
    ctx.shadowColor = '#00eeff';
    ctx.shadowBlur  = 16 * pct;
    // Hue shift along trail  cyan‚Üíwhite‚Üíorange
    const hue = pct > 0.6 ? `hsl(${195 - (pct-0.6)*300}, 100%, 70%)` : '#00eeff';
    ctx.fillStyle = hue;
    ctx.beginPath();
    ctx.arc(t.x, t.y, Math.max(0.5, r), 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // ‚îÄ‚îÄ Ball core ‚îÄ‚îÄ
  ctx.save();
  ctx.shadowColor = '#00eeff';
  ctx.shadowBlur  = 36;
  const grad = ctx.createRadialGradient(ball.x - 2, ball.y - 3, 1, ball.x, ball.y, BALL_RADIUS);
  grad.addColorStop(0, '#ffffff');
  grad.addColorStop(0.4, '#aaf8ff');
  grad.addColorStop(1,   '#00eeff');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

/* ================================================================
   6. PADDLES
================================================================ */
let paddleL = {}, paddleR = {};

function createPaddles() {
  paddleL = {
    x: PADDLE_MARGIN,
    y: H / 2 - PADDLE_H / 2,
    w: PADDLE_W, h: PADDLE_H,
    color: '#00eeff',
    glow:  '#00eeff',
    hitFlash: 0,
  };
  paddleR = {
    x: W - PADDLE_MARGIN - PADDLE_W,
    y: H / 2 - PADDLE_H / 2,
    w: PADDLE_W, h: PADDLE_H,
    color: '#ff6a00',
    glow:  '#ff6a00',
    hitFlash: 0,
  };
}

function updatePaddleL(dt) {
  const spd = 7;
  if (keys['w'] || keys['W'] || keys['ArrowUp'])   paddleL.y -= spd * dt;
  if (keys['s'] || keys['S'] || keys['ArrowDown'])  paddleL.y += spd * dt;
  paddleL.y = clamp(paddleL.y, 0, H - paddleL.h);
  if (paddleL.hitFlash > 0) paddleL.hitFlash -= dt;
}

// AI error target (recalculated occasionally)
let aiTarget = H / 2;
let aiRecalcTimer = 0;

function updatePaddleR(dt) {
  const cfg = DIFF[difficulty];
  aiRecalcTimer -= dt;
  if (aiRecalcTimer <= 0) {
    aiRecalcTimer = 8 + Math.random() * 10;  // recalc every ~8-18 frames
    // Predictive: estimate where ball will be when it reaches right side
    let predictY = ball.y;
    if (cfg.aiPredict > 0 && ball.vx > 0 && ball.delay <= 0) {
      predictY = predictBallY();
    }
    // Blend between reactive and predictive based on aiPredict value
    const reactiveY  = ball.y;
    const blendedY   = reactiveY + (predictY - reactiveY) * cfg.aiPredict;
    // Add random error
    const error = (Math.random() - 0.5) * 2 * cfg.aiError;
    aiTarget = blendedY + error;
  }

  const desiredTop = aiTarget - paddleR.h / 2;
  const delta      = desiredTop - paddleR.y;
  const step       = cfg.aiSpeed * dt;
  paddleR.y       += clamp(delta, -step, step);
  paddleR.y        = clamp(paddleR.y, 0, H - paddleR.h);
  if (paddleR.hitFlash > 0) paddleR.hitFlash -= dt;
}

/* Predict Y position of ball when it reaches right paddle X */
function predictBallY() {
  let x  = ball.x, y = ball.y;
  let vx = ball.vx, vy = ball.vy;
  const targetX = paddleR.x;
  let steps = 0;
  while (x < targetX && steps < 600) {
    x += vx * 1;
    y += vy * 1;
    if (y - BALL_RADIUS <= 0)   { y = BALL_RADIUS;      vy = Math.abs(vy); }
    if (y + BALL_RADIUS >= H)   { y = H - BALL_RADIUS;  vy = -Math.abs(vy); }
    steps++;
  }
  return y;
}

function drawPaddle(p) {
  ctx.save();

  const flash = Math.max(0, p.hitFlash);
  const glow  = flash > 0 ? '#ffffff' : p.glow;
  const blur  = flash > 0 ? 50 + flash * 4 : 22;

  // Outer aura
  ctx.shadowColor = glow;
  ctx.shadowBlur  = blur;
  ctx.globalAlpha = 0.15;
  ctx.fillStyle   = glow;
  const aw = p.w + 16, ah = p.h + 8;
  drawRoundRect(p.x - 8, p.y - 4, aw, ah, 10);
  ctx.fill();

  // Core paddle
  ctx.globalAlpha = 1;
  ctx.shadowColor = glow;
  ctx.shadowBlur  = blur * 0.7;
  const grad = ctx.createLinearGradient(p.x, p.y, p.x + p.w, p.y);
  grad.addColorStop(0, lighten(p.color, 0.5));
  grad.addColorStop(0.5, p.color);
  grad.addColorStop(1, lighten(p.color, 0.2));
  ctx.fillStyle = grad;
  drawRoundRect(p.x, p.y, p.w, p.h, 5);
  ctx.fill();

  // Highlight stripe
  ctx.globalAlpha = 0.4;
  ctx.fillStyle   = 'rgba(255,255,255,0.5)';
  drawRoundRect(p.x + 2, p.y + 4, 3, p.h - 8, 2);
  ctx.fill();

  ctx.restore();
}

/* ================================================================
   7. COLLISION DETECTION
================================================================ */
function handleCollisions() {
  // Wall collisions (top / bottom)
  if (ball.y - BALL_RADIUS <= 0) {
    ball.y  = BALL_RADIUS;
    ball.vy = Math.abs(ball.vy);
    spawnWallSpark(ball.x, 0);
  }
  if (ball.y + BALL_RADIUS >= H) {
    ball.y  = H - BALL_RADIUS;
    ball.vy = -Math.abs(ball.vy);
    spawnWallSpark(ball.x, H);
  }

  // Left paddle
  if (ballIntersects(paddleL) && ball.vx < 0) {
    bounceOffPaddle(paddleL, 1);
    paddleL.hitFlash = 14;
  }
  // Right paddle
  if (ballIntersects(paddleR) && ball.vx > 0) {
    bounceOffPaddle(paddleR, -1);
    paddleR.hitFlash = 14;
  }

  // Scoring
  if (ball.x - BALL_RADIUS < 0) {
    scoreR++;
    scoreFlashR = 30;
    spawnScoreParticles(60, H / 2, '#ff6a00');
    checkWin();
    if (gameState === STATE.PLAYING) createBall(-1);
  }
  if (ball.x + BALL_RADIUS > W) {
    scoreL++;
    scoreFlashL = 30;
    spawnScoreParticles(W - 60, H / 2, '#00eeff');
    checkWin();
    if (gameState === STATE.PLAYING) createBall(1);
  }
}

function ballIntersects(p) {
  return ball.x - BALL_RADIUS < p.x + p.w &&
         ball.x + BALL_RADIUS > p.x &&
         ball.y - BALL_RADIUS < p.y + p.h &&
         ball.y + BALL_RADIUS > p.y;
}

function bounceOffPaddle(p, dirX) {
  const cfg = DIFF[difficulty];
  // Relative hit -1 (top edge) to +1 (bottom edge)
  const rel    = ((ball.y - (p.y + p.h / 2)) / (p.h / 2));
  const angle  = rel * 68 * Math.PI / 180;   // max 68¬∞ bounce angle

  ball.speed   = Math.min(ball.speed + cfg.speedBoost, cfg.maxSpeed);
  ball.vx      = dirX * ball.speed * Math.cos(angle);
  ball.vy      = ball.speed * Math.sin(angle);

  // Resolve overlap
  if (dirX > 0) ball.x = p.x + p.w + BALL_RADIUS + 1;
  else           ball.x = p.x - BALL_RADIUS - 1;

  // Spawn sparks at hit point
  spawnHitSparks(ball.x, ball.y, dirX > 0 ? p.color : p.color);
}

function spawnWallSpark(x, y) {
  for (let i = 0; i < 12; i++) {
    const a = Math.random() * Math.PI;
    const s = 1 + Math.random() * 4;
    particles.push({
      x, y: clamp(y, 2, H - 2),
      vx: Math.cos(a) * s, vy: (y === 0 ? 1 : -1) * Math.abs(Math.sin(a) * s),
      life: 0.8, decay: 0.04 + Math.random() * 0.04,
      size: 1.5 + Math.random() * 2,
      color: '#aaf8ff', glow: '#00eeff',
    });
  }
}

function spawnHitSparks(x, y, color) {
  for (let i = 0; i < 22; i++) {
    const a = Math.random() * Math.PI * 2;
    const s = 1 + Math.random() * 5;
    particles.push({
      x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s,
      life: 0.9, decay: 0.03 + Math.random() * 0.04,
      size: 1.5 + Math.random() * 3,
      color, glow: color,
    });
  }
}

/* ================================================================
   8. SCORING & WIN
================================================================ */
function checkWin() {
  if (scoreL >= WIN_SCORE) { winner = 'player'; endGame(); }
  if (scoreR >= WIN_SCORE) { winner = 'ai';     endGame(); }
}

function endGame() {
  gameState = STATE.GAMEOVER;
  cancelAnimationFrame(animId);
  showGameOver();
}

/* ================================================================
   9. DRAWING / RENDERING
================================================================ */
function drawBackground() {
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#02030f';
  ctx.fillRect(0, 0, W, H);

  // Subtle radial gradient centre glow
  const rg = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, W*0.65);
  rg.addColorStop(0, 'rgba(0,100,120,0.06)');
  rg.addColorStop(1, 'transparent');
  ctx.fillStyle = rg;
  ctx.fillRect(0, 0, W, H);
}

function drawCourt() {
  // Centre dashed line
  ctx.save();
  ctx.setLineDash([14, 18]);
  ctx.strokeStyle = 'rgba(255,255,255,0.07)';
  ctx.lineWidth   = 2;
  ctx.beginPath();
  ctx.moveTo(W / 2, 0);
  ctx.lineTo(W / 2, H);
  ctx.stroke();
  ctx.setLineDash([]);

  // Centre circle
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth   = 1.5;
  ctx.beginPath();
  ctx.arc(W / 2, H / 2, 56, 0, Math.PI * 2);
  ctx.stroke();

  // Corner brackets
  const bSize = 20, bThick = 2, bPad = 0;
  ctx.strokeStyle = 'rgba(0,238,255,0.18)';
  ctx.lineWidth   = bThick;
  const corners = [
    [bPad, bPad, 1, 1], [W - bPad, bPad, -1, 1],
    [bPad, H - bPad, 1, -1], [W - bPad, H - bPad, -1, -1],
  ];
  for (const [cx, cy, sx, sy] of corners) {
    ctx.beginPath();
    ctx.moveTo(cx + sx * bSize, cy);
    ctx.lineTo(cx, cy);
    ctx.lineTo(cx, cy + sy * bSize);
    ctx.stroke();
  }

  ctx.restore();
}

function drawHUD() {
  // ‚îÄ‚îÄ Top bar ‚îÄ‚îÄ
  const barH = 48;
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.fillRect(0, 0, W, barH);
  ctx.strokeStyle = 'rgba(0,238,255,0.1)';
  ctx.lineWidth   = 1;
  ctx.strokeRect(0, 0, W, barH);

  // Difficulty tag
  const cfg = DIFF[difficulty];
  ctx.font      = '500 11px ' + 'Rajdhani, sans-serif';
  ctx.fillStyle = cfg.color + 'aa';
  ctx.textAlign = 'center';
  ctx.fillText('‚óà ' + cfg.label + ' ‚óà', W / 2, 18);

  // Scores
  const flashL = scoreFlashL > 0;
  const flashR = scoreFlashR > 0;

  ctx.font        = '900 28px Orbitron, monospace';
  ctx.textAlign   = 'center';

  // Player (left)
  ctx.fillStyle   = flashL ? '#ffffff' : 'rgba(0,238,255,0.85)';
  ctx.shadowColor = '#00eeff';
  ctx.shadowBlur  = flashL ? 40 : 14;
  ctx.fillText(scoreL, W / 2 - 80, 36);

  // AI (right)
  ctx.fillStyle   = flashR ? '#ffffff' : 'rgba(255,106,0,0.85)';
  ctx.shadowColor = '#ff6a00';
  ctx.shadowBlur  = flashR ? 40 : 14;
  ctx.fillText(scoreR, W / 2 + 80, 36);

  // Labels
  ctx.font      = '400 9px Rajdhani, sans-serif';
  ctx.shadowBlur = 0;

  ctx.fillStyle = 'rgba(0,238,255,0.35)';
  ctx.fillText('PLAYER', W / 2 - 80, 48);

  ctx.fillStyle = 'rgba(255,106,0,0.35)';
  ctx.fillText('AI', W / 2 + 80, 48);

  // Separator dots
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.font      = '14px Orbitron, monospace';
  ctx.fillText(':', W / 2, 36);

  if (scoreFlashL > 0) scoreFlashL--;
  if (scoreFlashR > 0) scoreFlashR--;

  ctx.restore();
}

/* ================================================================
   10. MAIN RENDER CALL
================================================================ */
function render() {
  drawBackground();
  drawCourt();
  drawParticles();
  drawBall();
  drawPaddle(paddleL);
  drawPaddle(paddleR);
  drawHUD();
}

/* ================================================================
   11. OVERLAY / UI MANAGEMENT
================================================================ */
const overlay = document.getElementById('overlay');
const pauseBadge = document.getElementById('pause-badge');

function showStartScreen() {
  overlay.classList.remove('hidden', 'fade-out');
  overlay.innerHTML = `
    <div class="title-wrap">
      <div class="game-title">NEON REBOUND X</div>
      <div class="title-sub">ARCADE EDITION &nbsp;‚óà&nbsp; ZERO MERCY</div>
    </div>
    <div class="sep"></div>
    <div class="section-label">Select Difficulty</div>
    <div class="diff-row">
      <button class="diff-btn easy  ${difficulty==='easy'  ?'active':''}" data-d="easy">Easy</button>
      <button class="diff-btn medium ${difficulty==='medium'?'active medium':''}" data-d="medium">Medium</button>
      <button class="diff-btn hard  ${difficulty==='hard'  ?'active hard':''}" data-d="hard">Hard</button>
    </div>
    <button class="cta-btn" id="cta">‚ñ∂ &nbsp; START GAME</button>
    <div class="hint-row">
      W / S &nbsp;‚Äî&nbsp; Move paddle &nbsp;&nbsp;|&nbsp;&nbsp; P &nbsp;‚Äî&nbsp; Pause<br>
      First to <strong>7 points</strong> wins
    </div>`;

  // Diff buttons
  overlay.querySelectorAll('.diff-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      difficulty = btn.dataset.d;
      overlay.querySelectorAll('.diff-btn').forEach(b => {
        b.classList.remove('active','medium','hard');
      });
      btn.classList.add('active');
      if (difficulty === 'medium') btn.classList.add('medium');
      if (difficulty === 'hard')   btn.classList.add('hard');
    });
  });
  overlay.querySelector('#cta').addEventListener('click', startGame);
}

function showGameOver() {
  overlay.classList.remove('hidden');
  overlay.style.opacity = '0';
  setTimeout(() => {
    overlay.style.transition = 'opacity 0.5s';
    overlay.style.opacity    = '1';
  }, 20);

  const isPlayer = winner === 'player';
  const color    = isPlayer ? '#00ff88' : '#ff2255';
  const label    = isPlayer ? 'PLAYER' : 'AI';
  const msg      = isPlayer ? 'VICTORY!' : 'DEFEATED!';
  const icon     = isPlayer ? 'üèÜ' : 'üíÄ';

  overlay.innerHTML = `
    <div class="title-wrap">
      <div class="game-title" style="font-size:clamp(1.6rem,4vw,3rem)">${icon} ${msg}</div>
      <div class="title-sub" style="color:${color}aa; letter-spacing:0.3em">${label} WINS ¬∑ ${scoreL} ‚Äî ${scoreR}</div>
    </div>
    <div class="sep" style="margin-bottom:32px"></div>
    <div class="section-label">Change Difficulty</div>
    <div class="diff-row">
      <button class="diff-btn easy   ${difficulty==='easy'  ?'active':''}" data-d="easy">Easy</button>
      <button class="diff-btn medium ${difficulty==='medium'?'active medium':''}" data-d="medium">Medium</button>
      <button class="diff-btn hard   ${difficulty==='hard'  ?'active hard':''}" data-d="hard">Hard</button>
    </div>
    <button class="cta-btn" id="cta">‚Ü∫ &nbsp; PLAY AGAIN</button>
    <div class="hint-row">ENTER &nbsp;‚Äî&nbsp; Quick restart with same settings</div>`;

  overlay.querySelectorAll('.diff-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      difficulty = btn.dataset.d;
      overlay.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active','medium','hard'));
      btn.classList.add('active');
      if (difficulty === 'medium') btn.classList.add('medium');
      if (difficulty === 'hard')   btn.classList.add('hard');
    });
  });
  overlay.querySelector('#cta').addEventListener('click', startGame);
}

function hideOverlay() {
  overlay.style.transition = 'opacity 0.45s';
  overlay.style.opacity    = '0';
  setTimeout(() => { overlay.classList.add('hidden'); overlay.style.opacity = ''; }, 460);
}

function togglePause() {
  if (gameState === STATE.PLAYING) {
    gameState = STATE.PAUSED;
    pauseBadge.style.display = 'block';
    cancelAnimationFrame(animId);
  } else if (gameState === STATE.PAUSED) {
    gameState = STATE.PLAYING;
    pauseBadge.style.display = 'none';
    lastTs = performance.now();
    animId = requestAnimationFrame(loop);
  }
}

/* ================================================================
   12. INPUT HANDLING
================================================================ */
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key] = true;

  if (e.key === 'p' || e.key === 'P') {
    if (gameState === STATE.PLAYING || gameState === STATE.PAUSED) togglePause();
  }
  if (e.key === 'Enter') {
    if (gameState === STATE.GAMEOVER || gameState === STATE.START) startGame();
    else if (gameState === STATE.PAUSED) togglePause();
  }
  // Prevent arrow key scrolling
  if (['ArrowUp','ArrowDown',' '].includes(e.key)) e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.key] = false; });

/* ================================================================
   13. MAIN GAME LOOP
================================================================ */
function loop(ts) {
  if (gameState !== STATE.PLAYING) return;

  // Delta time ‚Äî normalised to 60fps units, capped to avoid spiral of death
  const dt = Math.min((ts - lastTs) / (1000 / 60), 4);
  lastTs   = ts;

  // Update
  updateBall(dt);
  updatePaddleL(dt);
  updatePaddleR(dt);
  handleCollisions();
  updateParticles(dt);

  // Render
  render();

  animId = requestAnimationFrame(loop);
}

/* ================================================================
   14. START / INIT
================================================================ */
function startGame() {
  // Reset state
  scoreL    = 0;
  scoreR    = 0;
  winner    = null;
  particles = [];
  scoreFlashL = scoreFlashR = 0;

  createPaddles();
  createBall(Math.random() < 0.5 ? 1 : -1);

  hideOverlay();
  pauseBadge.style.display = 'none';

  gameState = STATE.PLAYING;
  lastTs    = performance.now();

  cancelAnimationFrame(animId);
  animId = requestAnimationFrame(loop);
}

/* ================================================================
   UTILITY HELPERS
================================================================ */
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

function lighten(hex, amount) {
  const n = parseInt(hex.replace('#', ''), 16);
  const r = Math.min(255, ((n >> 16) & 0xff) + Math.round(255 * amount));
  const g = Math.min(255, ((n >> 8)  & 0xff) + Math.round(255 * amount));
  const b = Math.min(255, ( n        & 0xff) + Math.round(255 * amount));
  return `rgb(${r},${g},${b})`;
}

function drawRoundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

/* ================================================================
   BOOT ‚Äî draw idle frame then show start screen
================================================================ */
(function boot() {
  createPaddles();
  createBall(1);
  drawBackground();
  drawCourt();
  drawPaddle(paddleL);
  drawPaddle(paddleR);
  showStartScreen();
})();
</script>
</body>
</html>
